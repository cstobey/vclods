function tbl(sub_tt) {print "CREATE OR REPLACE TEMPORARY TABLE "sub_tt" (KEY (id)) AS"}
function cc_ws(value, sep, new) {return (value=="") ? new : value sep new}
function tail() {ret=""; for (i=4; i<=NF; i++) ret=cc_ws(ret," ",$i); return ret}
function csv(tt_id, sub_tt, source) {print "SELECT "tt"."tt_id" AS id, SUBSTRING_INDEX(SUBSTRING_INDEX("source", \x27,\x27, s.seq+1), \x27,\x27, -1) AS the_value, s.seq AS index_number\nFROM "tt" JOIN seq_0_to_1000 AS s ON s.seq <= LENGTH("source") - LENGTH(REPLACE("source", \x27,\x27, \x27\x27)) AND LENGTH("source");";
  print "ALTER TABLE "sub_tt" ADD INDEX (index_number);"}
function json_shallow(tt_id, sub_tt, source) {print "WITH t AS (SELECT "tt_id" AS id, "source" AS j FROM " tt ")\
  SELECT\
    t.id,\
    CASE JSON_TYPE(t.j)\
      WHEN \x27ARRAY\x27 THEN s.seq\
      WHEN \x27OBJECT\x27 THEN JSON_VALUE(JSON_KEYS(t.j), CONCAT(\x27$[\x27, s.seq, \x27]\x27))\
      ELSE NULL\
    END AS the_key,\
    CASE JSON_TYPE(t.j)\
      WHEN \x27ARRAY\x27 THEN JSON_EXTRACT(t.j, CONCAT(\x27$[\x27, s.seq, \x27]\x27))\
      WHEN \x27OBJECT\x27 THEN JSON_EXTRACT(t.j, CONCAT(\x27$.\x27, JSON_QUOTE(JSON_VALUE(JSON_KEYS(t.j), CONCAT(\x27$[\x27, s.seq, \x27]\x27)))))\
      ELSE t.j\
    END AS the_value\
  FROM t\
  JOIN seq_0_to_1000 AS s ON s.seq < JSON_LENGTH(t.j);";
  print "ALTER TABLE "sub_tt" ADD INDEX (the_key(555));"}
function json_deep(tt_id, sub_tt, source) {print "WITH RECURSIVE t AS (SELECT "tt_id" AS id, "source" AS j FROM " tt "),\
  r AS (SELECT\
    t.id, t.j AS full, 1 AS depth,\
    CONCAT(\x27$\x27, CASE JSON_TYPE(t.j) WHEN \x27OBJECT\x27 THEN CONCAT(\x27.\x27, JSON_VALUE(JSON_KEYS(t.j), CONCAT(\x27$[\x27, s.seq, \x27]\x27))) WHEN \x27ARRAY\x27 THEN CONCAT(\x27[\x27, s.seq, \x27]\x27) ELSE \x27\x27 END) AS the_jpath,\
    JSON_VALUE(JSON_KEYS(t.j), CONCAT(\x27$[\x27, s.seq, \x27]\x27)) AS the_key,\
    CASE JSON_TYPE(t.j)\
      WHEN \x27ARRAY\x27 THEN JSON_EXTRACT(t.j, CONCAT(\x27$[\x27, s.seq, \x27]\x27))\
      WHEN \x27OBJECT\x27 THEN JSON_EXTRACT(t.j, CONCAT(\x27$.\x27, JSON_QUOTE(JSON_VALUE(JSON_KEYS(t.j), CONCAT(\x27$[\x27, s.seq, \x27]\x27)))))\
      ELSE t.j\
    END AS the_value\
  FROM t\
  JOIN seq_0_to_1000 AS s ON s.seq < JSON_LENGTH(t.j)\
  UNION ALL\
  SELECT\
    r.id, r.full, r.depth + 1 AS depth,\
    CONCAT(r.the_jpath, IFNULL(CONCAT(\x27.\x27, JSON_VALUE(JSON_KEYS(r.the_value), CONCAT(\x27$[\x27, s.seq, \x27]\x27))), CONCAT(\x27[\x27, s.seq, \x27]\x27))) AS the_jpath,\
    JSON_VALUE(JSON_KEYS(r.the_value), CONCAT(\x27$[\x27, s.seq, \x27]\x27)) AS the_key,\
    CASE JSON_TYPE(r.the_value)\
      WHEN \x27ARRAY\x27 THEN JSON_EXTRACT(r.the_value, CONCAT(\x27$[\x27, s.seq, \x27]\x27))\
      WHEN \x27OBJECT\x27 THEN JSON_EXTRACT(r.the_value, CONCAT(\x27$.\x27, JSON_QUOTE(JSON_VALUE(JSON_KEYS(r.the_value), CONCAT(\x27$[\x27, s.seq, \x27]\x27)))))\
    END AS the_value\
  FROM r\
  JOIN seq_0_to_1000 AS s ON s.seq < JSON_LENGTH(r.the_value) AND JSON_TYPE(r.the_value) IN (\x27ARRAY\x27, \x27OBJECT\x27))\
SELECT id, the_jpath, the_key, NULLIF(JSON_UNQUOTE(the_value), \x27null\x27) AS the_value FROM r WHERE IFNULL(JSON_TYPE(r.the_value), \x27\x27) NOT IN (\x27ARRAY\x27, \x27OBJECT\x27) OR the_value IN (\x27[]\x27, \x27{}\x27);";
  print "ALTER TABLE "sub_tt" ADD INDEX (the_key(555)), ADD INDEX (the_jpath(555));"}
function manual(tt_id, sub_tt, source) {system("cat \x22$ETL_EXT_DIR/"source"\x22")}

$2~/^#explode_(csv|json_(shallow|deep)|manual)$/ {tbl($3); f_type=gensub(/^#explode_(.*)$/, "\\1", "g", $2); @f_type($1, $3, tail());}
