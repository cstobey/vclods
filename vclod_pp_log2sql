#! /bin/ksh
# Parses log messages from $LOG_FILE (program output) in $LF (the log file) and splits them to a database (LOG_SQL_DB).
# Rejected messages go to LF.sql_failed. Requires a program that outputs in this format:
# date time pid [tag] message...
# This script fulfills the VCLOD logger contract, but could technically work with any properly structured log file.

# Usage:
# normal usage is as part of the post process parsing in vclod_stdio, but can also be run manually
# ./my_program > program.out.log; LOG_FILE_OVERRIDE=/script/dir/script_name.extention.list LF_OVERRIDE=/path/to/final.out.log vclod ./vclod_pp_log2sql

# Argument validation: LF is the actual log file. NOTE: most arguments have multiple names.
: ${LOG_FILE:=${LOG_FILE_OVERRIDE:?}} ${LF:=${LF_OVERRIDE:?}} ${LOG_SQL_HOST:?} ${LOG_SQL_USER:=$LOG_USER} ${LOG_SQL_PASSWORD:=$LOG_PW} ${LOG_SQL_DB:?} ${LOG_SQL_ENGINE:=$LOG_ENGINE}
[ -s "$LF" ] || exit # if the output file is empty, dont try to store it

export SRC="$(vclod_connection LOG_SQL_)"
export INPUT_DIR="$VCLOD_BASE_DIR"  # NOTE: this feels weird, but it enables the etl files to be global

# Parse each line of a log file, expecting format (space separated):
# (<date> <time>) <pid> [<tag>] (<message>... <optional_value>)
# and ingest into the .etl format
sed -r 's/"/\\"/g;s/\t/ /g;s/^([^ ]+ +[^ ]+) +([^ ]+) +([^ ]+) +(.*)$/("\1","\2","\3","\4")/' "$LF" | vclod_operation pp_log2sql.sql.batch.etl-pp_etl_log2sql || mv $LF "$LF.sql_failed"
