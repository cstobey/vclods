function tbl(sub_tt) {print "CREATE OR REPLACE TEMPORARY TABLE "sub_tt" (KEY (id)) AS"}
function cc_ws(value, sep, new) {return (value=="") ? new : value sep new}
function tail() {ret=""; for (i=4; i<=NF; i++) ret=cc_ws(ret," ",$i); return ret}
function csv(tt_id, sub_tt, source) {print "SELECT "tt"."tt_id" AS id, SUBSTRING_INDEX(SUBSTRING_INDEX("source", ',', s.seq+1), ',', -1) AS the_value, s.seq AS index_number\nFROM "tt" JOIN seq_0_to_1000 AS s ON s.seq <= LENGTH("source") - LENGTH(REPLACE("source", ',', '')) AND LENGTH("source");";
  print "ALTER TABLE "sub_tt" ADD INDEX (index_number);"}
function json_shallow(tt_id, sub_tt, source) {print "WITH t AS (SELECT "tt_id" AS id, "source" AS j FROM " tt ")\
  SELECT\
    t.id,\
    CASE JSON_TYPE(t.j)\
      WHEN 'ARRAY' THEN s.seq\
      WHEN 'OBJECT' THEN JSON_VALUE(JSON_KEYS(t.j), CONCAT('$[', s.seq, ']'))\
      ELSE NULL\
    END AS the_key,\
    CASE JSON_TYPE(t.j)\
      WHEN 'ARRAY' THEN JSON_EXTRACT(t.j, CONCAT('$[', s.seq, ']'))\
      WHEN 'OBJECT' THEN JSON_EXTRACT(t.j, CONCAT('$.', JSON_QUOTE(JSON_VALUE(JSON_KEYS(t.j), CONCAT('$[', s.seq, ']')))))\
      ELSE t.j\
    END AS the_value\
  FROM t\
  JOIN seq_0_to_1000 AS s ON s.seq < JSON_LENGTH(t.j);";
  print "ALTER TABLE "sub_tt" ADD INDEX (the_key(555));"}
function json_deep(tt_id, sub_tt, source) {print "WITH RECURSIVE t AS (SELECT "tt_id" AS id, "source" AS j FROM " tt "),\
  r AS (SELECT\
    t.id, t.j AS full, 1 AS depth,\
    CONCAT('$', CASE JSON_TYPE(t.j) WHEN 'OBJECT' THEN CONCAT('.', JSON_VALUE(JSON_KEYS(t.j), CONCAT('$[', s.seq, ']'))) WHEN 'ARRAY' THEN CONCAT('[', s.seq, ']') ELSE '' END) AS the_jpath,\
    JSON_VALUE(JSON_KEYS(t.j), CONCAT('$[', s.seq, ']')) AS the_key,\
    CASE JSON_TYPE(t.j)\
      WHEN 'ARRAY' THEN JSON_EXTRACT(t.j, CONCAT('$[', s.seq, ']'))\
      WHEN 'OBJECT' THEN JSON_EXTRACT(t.j, CONCAT('$.', JSON_QUOTE(JSON_VALUE(JSON_KEYS(t.j), CONCAT('$[', s.seq, ']')))))\
      ELSE t.j\
    END AS the_value\
  FROM t\
  JOIN seq_0_to_1000 AS s ON s.seq < JSON_LENGTH(t.j)\
  UNION ALL\
  SELECT\
    r.id, r.full, r.depth + 1 AS depth,\
    CONCAT(r.the_jpath, IFNULL(CONCAT('.', JSON_VALUE(JSON_KEYS(r.the_value), CONCAT('$[', s.seq, ']'))), CONCAT('[', s.seq, ']'))) AS the_jpath,\
    JSON_VALUE(JSON_KEYS(r.the_value), CONCAT('$[', s.seq, ']')) AS the_key,\
    CASE JSON_TYPE(r.the_value)\
      WHEN 'ARRAY' THEN JSON_EXTRACT(r.the_value, CONCAT('$[', s.seq, ']'))\
      WHEN 'OBJECT' THEN JSON_EXTRACT(r.the_value, CONCAT('$.', JSON_QUOTE(JSON_VALUE(JSON_KEYS(r.the_value), CONCAT('$[', s.seq, ']')))))\
    END AS the_value\
  FROM r\
  JOIN seq_0_to_1000 AS s ON s.seq < JSON_LENGTH(r.the_value) AND JSON_TYPE(r.the_value) IN ('ARRAY', 'OBJECT'))\
SELECT id, the_jpath, the_key, NULLIF(JSON_UNQUOTE(the_value), 'null') AS the_value FROM r WHERE IFNULL(JSON_TYPE(r.the_value), '') NOT IN ('ARRAY', 'OBJECT') OR the_value IN ('[]', '{}');";
  print "ALTER TABLE "sub_tt" ADD INDEX (the_key(555)), ADD INDEX (the_jpath(555));"}
function manual(tt_id, sub_tt, source) {system("cat \x22$ETL_EXT_DIR/"source"\x22")}

$2~/^#explode_(csv|json_(shallow|deep))$/ {tbl($3);}
$2~/^#explode_(csv|json_(shallow|deep)|manual)$/ {f_type=gensub(/^#explode_(.*)$/, "\\1", "g", $2); @f_type($1, $3, tail());}
