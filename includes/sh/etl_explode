etl_explode_coroutine () {
  return 0
  set -x
  while read tmp_tbl_id explode_type sub_tmp_tbl sub_tmp_tbl_source ; do 
    :>"$COROUTINE_FILE"
    print -p "CREATE OR REPLACE TEMPORARY TABLE $sub_tmp_tbl (" || return 1
    print -p "  $(grep -wm1 "$tmp_tbl_id" "$ETL_TBL_TEMP_FILE" | sed -r 's/^\s*\S+(.*)(\s+(PRIMARY\s+KEY|AUTO_INCREMENT|UNIQUE(\s+KEY)?))*\s*,\s*#.*$/id\1,/')" || return 1
    # TODO: build the sub_tmp_table... need to get the id type from the main table, remembering to take off any PRIMARY KEY clause
    # TODO: pull the data and do something with it, then put it back
    # TODO: at some point, need to figure out how to do a #run?
    case "$explode_type" in
      "#explode_csv")
        print -p "  the_value VARCHAR(6000), index_number INT NOT NULL, KEY(id), KEY(index_number));" || return 1
        print -p "SELECT ${tmp_tbl}.${tmp_tbl_id}, ${sub_tmp_tbl_source} FROM ${tmp_tbl};SELECT '#END NOW';" || return 1
        while read -p i l || return 1 ; do
          [ "$i $l" == "#END NOW" ] && break 
          echo "$i,$l" ; 
        done | sed -r 's/"/\\"/g;s/(^|$)/"/g;s/,/","/g' | awk -F',' '{for (i=2; i<=NF; i++) print "("$1","$i","(i-2)")"}' >$COROUTINE_FILE
        ;;
      "#explode_json_shallow")
        print -p "  the_key VARCHAR(1024), the_value VARCHAR(6000), KEY (id), KEY (the_key(555)));" || return 1
        print -p "SELECT ${tmp_tbl}.${tmp_tbl_id}, ${sub_tmp_tbl_source} FROM ${tmp_tbl};SELECT '#END NOW';" || return 1
        while read -r i l || return 1 ; do
          [ "$i $l" == "#END NOW" ] && break
          jq -r --arg i "$i" --arg q "'" 'to_entries[] | "(\($i),\($q)\(.key | @json)\($q),\($q)\(.value | @json)\($q))"' <<<"$l"
        done >$COROUTINE_FILE
        ;;
      "#explode_json_deep")
        print -p "  the_jpath VARCHAR(6000), the_key VARCHAR(1024), the_value VARCHAR(6000), KEY (id), KEY (the_key(555)), KEY (the_jpath(555)));" || return 1
        print -p "SELECT ${tmp_tbl}.${tmp_tbl_id}, ${sub_tmp_tbl_source} FROM ${tmp_tbl};SELECT '#END NOW';" || return 1
        while read -r i l || return 1 ; do
          [ "$i $l" == "#END NOW" ] && break
          jq -r --stream --arg i "$i" --arg q "'" 'select(has(1)) | "(\($i),\($q)$\(first | map(if type == "number" then "["+(.|tostring)+"]" else "."+. end) | join(""))\($q),\($q)\(last | @json)\($q))"' <<<"$l"
        done >$COROUTINE_FILE
        ;;
      "#explode_manual")
        f="${sub_tmp_tbl_source%%.*}"
        if [ -s "${ETL_EXT_DIR}/$f" ] ; then
          pipe_to_coroutine <"${ETL_EXT_DIR}/$f" || return 1
          if [ "$f" != "$sub_tmp_tbl_source" ] ; then
            print -p "SELECT '#END NOW';"
            while read -p l || return 1 ; do [ "$l" == "#END NOW" ] && break ; echo "$l" ; done >$COROUTINE_FILE
            vclod_operation "$sub_tmp_tbl_source" <"$COROUTINE_FILE" | pipe_to_coroutine || return 1
          fi
        fi
        :>"$COROUTINE_FILE"
        ;;
    esac
    [ -s "$COROUTINE_FILE" ] && cat <(echo "#start INSERT INTO $sub_tmp_tbl") "$COROUTINE_FILE" | vclod_operation explode_input_batch.batch | pipe_to_coroutine || return 1
  done
  set +x
}
