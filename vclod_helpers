#! /bin/ksh
# helper functions
add_file_cleanup () { trap "rm -f $*$(trap -p EXIT | sed -r 's/;+/;/g;s/^;//;s/;$//;s/^(.)/;\1/')" EXIT; } # TODO: handle spaces?

literate_source () {
  # envsubst only does variable substitution
  # heredocs do variable substitution, variable expansion, and process substitution
  # source (.) does the above and treats everything else as code too.
  # this function allows heredoc-level substitutions for any string.
  # the name comes from language systems that invert comments and code for executable blog posts (ie, like Literate Haskell)
  : "${HEREDOC_DELIMITER:=MSG}" # If multiple literate_source layers deep, use this to override the heredoc delimiter
  eval "cat << $HEREDOC_DELIMITER"$'\n'"$(<"${1:-/dev/stdin}")"$'\n'"$HEREDOC_DELIMITER"
}

vclod_connection() {
  CONN_PREFIX=${1:-VCLOD_OVERRIDE_}
  echo "ENGINE=\${${CONN_PREFIX}ENGINE:=${VCLOD_ENGINE:=mysql}}" | . /dev/stdin
  [ -f "${VCLOD_BASE_DIR%/}/connections/$ENGINE" ] || { echo >&2 "Unknown engine type $ENGINE" ; exit 1 ; }

  for v in HOST DB USER PASSWORD; do cat << EOF | . /dev/stdin ; done
$v=\${${CONN_PREFIX}${v}:-\${VCLOD_$(echo "$ENGINE" | tr '[:lower:]' '[:upper:]')_$v:-\${VCLOD_$v:?}}}
EOF
  HOST=$HOST DB=$DB USER=$USER PWORD=$PASSWORD envsubst <"${VCLOD_BASE_DIR%/}/connections/$ENGINE" # return the connection string
}

vclod_op(){
  next="${1%.*}"
  [[ "$1" == "$next" ]] && cat && return # The cat connects stdin to stdout, note that the error case below does not. This should never happen.
  extension="${1##*.}"
  ext="${extension%%-*}"
  ext_opt="$([ "$extension" = "$ext" ] || echo "${extension#*-}")"
  base_filename="${1%%.*}"
  op_ext_file="${VCLOD_BASE_DIR%/}/extensions/$ext"
  test -f "$op_ext_file" || { echo "Unknown file type $ext" >&2 ; exit 99 ; }
  if [[ "$next" == "${next%.*}" ]] ; then
    . "$op_ext_file"
  else
    . "$op_ext_file" | vclod_op "$next"
  fi
}
function vclod_operation {
  typeset exit_err_msg="${VCLOD_EXIT_ERR:-$(basename "$1")}"
  typeset ret=0
  unset VCLOD_EXIT_ERR # force each layer to have its own error context.
  vclod_op "$(basename "$1")" || { ret=$?; echo >&2 "$exit_err_msg returned $ret"; }
  return $ret
}

export add_file_cleanup literate_source vclod_connection vclod_operation
