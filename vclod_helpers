#! /bin/ksh
# helper functions
add_file_cleanup () { trap "rm -f $*$(trap -p EXIT | sed -r 's/;+/;/g;s/^;//;s/;$//;s/^(.)/;\1/')" EXIT; } # TODO: handle spaces?

literate_source () {
  # envsubst only does variable substitution
  # heredocs do variable substitution, variable expansion, and process substitution
  # source (.) does the above and treats everything else as code too.
  # this function allows heredoc-level substitutions for any string.
  # the name comes from language systems that invert comments and code for executable blog posts (ie, like Literate Haskell)
  : "${HEREDOC_DELIMITER:=MSG}" # If multiple literate_source layers deep, use this to override the heredoc delimiter
  echo "cat << $HEREDOC_DELIMITER"$'\n'"${@:-$(</dev/stdin)}"$'\n'"$HEREDOC_DELIMITER" | . /dev/stdin
}

### TODO: ${:?} error messages expose too much of VCLODS internals and obfuscate the actual error. come up with a way to make them more readable.
vclod_connection() {
  CONN_PREFIX=${1:=VCLOD_OVERRIDE_}
  ENGINE="$(printf 'echo ${%sENGINE:-${VCLOD_ENGINE:-mysql}}' "${CONN_PREFIX}" | . /dev/stdin | tr '[:upper:]' '[:lower:]')"
  ENGINE_U="$(echo "$ENGINE" | tr '[:lower:]' '[:upper:]')"
  [ -f "${VCLOD_BASE_DIR%/}/connections/$ENGINE" ] || { echo >&2 "Unknown engine type $ENGINE" ; exit 1 ; }

  printf '%s envsubst <"%s/connections/%s"' "$(for v in HOST DB USER PASSWORD; do 
    ## TODO: for some reason, high volumes of delayed resolving end up with random errors claiming unmatched {. Need to resolve this to allow on demand connection resolution... could be a fault with literate_source?
    #printf $'%s=\'${%s%s:-${VCLOD_%s_%s:-${VCLOD_%s:?Missing %s/%s conn arguments}}}\' ' "$v" "$CONN_PREFIX" "$v" "$ENGINE_U" "$v" "$v" "$CONN_PREFIX" "$ENGINE_U"; 
    printf '%s=${%s%s:-${VCLOD_%s_%s:-${VCLOD_%s:?Missing %s/%s conn arguments}}} ' "$v" "$CONN_PREFIX" "$v" "$ENGINE_U" "$v" "$v" "$CONN_PREFIX" "$ENGINE_U"; 
  done)" "${VCLOD_BASE_DIR%/}" "$ENGINE" | . /dev/stdin # return connection string
}

vclod_op(){
  next="${1%.*}"
  [[ "$1" == "$next" ]] && cat && return # The cat connects stdin to stdout, note that the error case below does not. This should never happen.
  extension="${1##*.}"
  ext="${extension%%-*}"
  ext_opt="$([ "$extension" = "$ext" ] || echo "${extension#*-}")"
  base_filename="${1%%.*}"
  op_ext_file="${VCLOD_BASE_DIR%/}/extensions/$ext"
  test -f "$op_ext_file" || { echo "Unknown file type $ext" >&2 ; exit 99 ; }
  if [[ "$next" == "${next%.*}" ]] ; then
    . "$op_ext_file"
  else
    . "$op_ext_file" | vclod_op "$next"
  fi
}
function vclod_operation {
  typeset exit_err_msg="${VCLOD_EXIT_ERR:-$(basename "$1")}"
  typeset ret=0
  unset VCLOD_EXIT_ERR # force each layer to have its own error context.
  vclod_op "$(basename "$1")" || { ret=$?; echo >&2 "$exit_err_msg returned $ret"; }
  return $ret
}

export add_file_cleanup literate_source vclod_connection vclod_operation
