#! /bin/ksh
# Launches all VCLOD batches defined in a directory, running up to VCLOD_JOBS at a time. 
#
# Usage (better to just use vclod installed script):
# ./vclod_do_dir /path/to/dir

. "${VCLOD_BASE_DIR:=$(dirname "$(readlink -f "$(which "$0")")")}/vclod_loadenv"

ulimit -s unlimited  # log files might get large, need to let them float in however much memory is needed/available.

# Argument validation
: "${1:?Missing a directory or file to process}"
: "${VCLOD_JOBS:=10}" # How many scripts to run in parallel. Must be at least 1 or nothing will happen.
: "${OPERATIONS_EMAIL:?}" # Email address list to send error output to
MAIL_ELF="${LOG_BASE_DIR}/$$.err" # used to send batched error emails.
[ -s "$MAIL_ELF" ] && : >"$MAIL_ELF" # force it to start empty

PIPE_FIFO="${VCLOD_LOCK_DIR%/}/pipe.$$.fifo" ; mkfifo "$PIPE_FIFO" ; exec 9<>"$PIPE_FIFO" ; add_file_cleanup "$PIPE_FIFO"
stdbuf -i0 -o0 -e0 seq 1 "$VCLOD_JOBS" >&9
post_exit_trap 'for j in "$(jobs -p)";do kill -SIGINT "$j" 2>/dev/null;done;[ -n "$(jobs -p)" ] && wait'

if [ ! -e "$1" ]; then # needs to be here instead of the next if because of the pipe.
  export pIN_FILE="$(mktemp)" # the p stands for private and prevents it from showing up in the doco
  add_file_cleanup "$pIN_FILE"
  cat >"$pIN_FILE" # not sure why this works here but not in run_script
fi

if [ -e "$1" ]; then
  find "$@" ! -empty -xtype f -regextype posix-egrep -regex "$VCLOD_FILE_REGEX" | sort -n
else
  printf '%s\n' "$1"
fi | while read filename ; do
  stdbuf -i0 -o0 -e0 read dummy <&9
  : | run_script "$filename" &
done
[ -n "$(jobs -p)" ] && wait
ret=$?
[ -s "$MAIL_ELF" ] && [ "$IS_TERMINAL" -eq 0 ] && mail -s "Script error digest on $(hostname)" "$OPERATIONS_EMAIL" <"$MAIL_ELF"
exit $ret
