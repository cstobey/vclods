#TERM push stdin to slack channel. Will propogate all data on.
: "${ext_opt:=${SLACK_EXT_CHANNEL:=vclod_logs}}" # Thus this only works if the bot is configured for multichannel use
: "${SLACK_EXT_EMOJI:=:robot_face:}" # Give it some style ;)
: "${SLACK_EXT_NAME:=$(hostname -s)}" # The username to use for the post
: "${SLACK_EXT_USE_RAW_TEXT:=0}" # if 1, use the input stream as the text, otherwise, use the script and log file paths
: "${SLACK_API_URL:?}" # must have an endpoint to send the logs to -- same one that errors use

TEMP_FILE="$(mktemp)"; add_file_cleanup "$TEMP_FILE"
cat >"$TEMP_FILE"

# TODO: if the data is too big, need to either shorten it, or batch it. currently just shortening it, might want to make that an option. might want the awk commands to be centralized between the 2 places
safe_payload="$(awk -v m="$(wc -l "$TEMP_FILE")" 'BEGIN {t=m-10;e=1;l=0} l <= 2996 && (NR <= 10 || NR > t) {l=l + length;if(l >= 2996) {e=0;print "..."} else print} NR > 10 && NR <= t && e {print "---"(m-20); e=0}' "$TEMP_FILE" | jq -Rs '.')"
if [ "$SLACK_EXT_USE_RAW_TEXT" -eq 1 ] ; then
  payload="$(cat << EOF
payload={"channel": "$ext_opt", "username": "$SLACK_EXT_NAME", "text": $safe_payload, "icon_emoji": "$SLACK_EXT_EMOJI"}
EOF
)"
else
  payload="$(cat << EOF
payload={"channel": "$ext_opt", "username": "$SLACK_EXT_NAME", "text": "$S : $LF", "icon_emoji": "$SLACK_EXT_EMOJI", "attachments": [{ "blocks": [{ "type": "section", "text": {"type": "plain_text", "text": $safe_payload } }] }] }
EOF
)"
fi
[ -s "$TEMP_FILE" ] && (curl -sSf -m15 --data-urlencode "$payload" "$SLACK_API_URL" >/dev/null || echo "[ERROR] slack: $payload")
cat "$TEMP_FILE"  # make it go to the logs as well?
